<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#0d1117">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Conduit">
<title>Conduit</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⚡</text></svg>">
<link rel="apple-touch-icon" href="/icon-192.png">
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
/* ================================================================ */
/* Reset & base                                                      */
/* ================================================================ */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0d1117; color: #e6edf3;
  font-family: -apple-system, 'Segoe UI', Helvetica, Arial, sans-serif;
  font-size: 14px; min-height: 100vh;
}
a { color: #58a6ff; text-decoration: none; }
a:hover { text-decoration: underline; }

/* ================================================================ */
/* Layout                                                            */
/* ================================================================ */
.header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 14px 24px; border-bottom: 1px solid #21262d;
  background: #161b22;
}
.header h1 { font-size: 16px; font-weight: 700; color: #f0883e; letter-spacing: 0.02em; }
.header .node-id { font-family: 'SF Mono', monospace; font-size: 11px; color: #8b949e; }

.wallet-bar {
  display: flex; gap: 24px; padding: 10px 24px; border-bottom: 1px solid #21262d;
  background: #0d1117; font-size: 13px; flex-wrap: wrap; align-items: center;
}
.wallet-bar .stat { display: flex; gap: 6px; align-items: center; }
.wallet-bar .stat-label { color: #8b949e; }
.wallet-bar .stat-value { color: #e6edf3; font-weight: 600; }
.wallet-bar .stat-value.btc { color: #f0883e; }

.tab-bar {
  display: flex; border-bottom: 1px solid #21262d; background: #161b22;
  overflow-x: auto;
}
.tab-bar button {
  background: none; border: none; color: #8b949e; font-family: inherit;
  font-size: 13px; padding: 10px 20px; cursor: pointer; border-bottom: 2px solid transparent;
  white-space: nowrap; transition: color 0.15s, border-color 0.15s;
}
.tab-bar button:hover { color: #e6edf3; }
.tab-bar button.active { color: #e6edf3; border-bottom-color: #f0883e; font-weight: 600; }

.tab-content { display: none; padding: 24px; max-width: 900px; margin: 0 auto; }
.tab-content.active { display: block; }

/* ================================================================ */
/* Settings panel                                                    */
/* ================================================================ */
.settings {
  background: #161b22; border: 1px solid #30363d; border-radius: 10px;
  padding: 16px 20px; margin-bottom: 24px;
}
.settings h3 { font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px; color: #8b949e; margin-bottom: 10px; }
.settings .row { display: flex; gap: 8px; margin-bottom: 8px; align-items: center; }
.settings label { color: #8b949e; font-size: 12px; min-width: 80px; }
.settings input {
  flex: 1; background: #0d1117; border: 1px solid #30363d; color: #e6edf3;
  padding: 6px 10px; border-radius: 6px; font-family: inherit; font-size: 13px;
}
.settings input:focus { border-color: #58a6ff; outline: none; }
.settings .status { font-size: 12px; color: #484f58; margin-top: 4px; }
.settings .status.ok { color: #3fb950; }

/* ================================================================ */
/* Cards & tables                                                    */
/* ================================================================ */
.card {
  background: #161b22; border: 1px solid #30363d; border-radius: 10px;
  padding: 20px; margin-bottom: 16px;
}
.card h3 { font-size: 13px; font-weight: 600; margin-bottom: 12px; color: #e6edf3; }
.card .empty { color: #484f58; font-size: 13px; font-style: italic; }

table { width: 100%; border-collapse: collapse; font-size: 13px; }
th {
  text-align: left; color: #8b949e; font-weight: 500; padding: 8px 10px;
  border-bottom: 1px solid #21262d; font-size: 11px; text-transform: uppercase;
  letter-spacing: 0.05em;
}
td { padding: 8px 10px; border-bottom: 1px solid #161b22; }
tr:hover td { background: #1c2128; }
.mono { font-family: 'SF Mono', monospace; font-size: 11px; color: #8b949e; word-break: break-all; }
.price { color: #f0883e; font-weight: 600; }
.badge {
  display: inline-block; padding: 2px 8px; border-radius: 9999px;
  font-size: 11px; font-weight: 600;
}
.badge-green { background: #1a2f1a; color: #3fb950; }
.badge-yellow { background: #2f2a1a; color: #d29922; }
.badge-red { background: #2f1a1a; color: #f85149; }
.badge-blue { background: #1a1f2f; color: #58a6ff; }

/* ================================================================ */
/* Buttons                                                           */
/* ================================================================ */
.btn {
  padding: 8px 16px; border: none; border-radius: 6px;
  font-size: 13px; font-weight: 600; cursor: pointer; font-family: inherit;
  transition: background 0.15s;
}
.btn-primary { background: #238636; color: #fff; }
.btn-primary:hover { background: #2ea043; }
.btn-primary:disabled { background: #21262d; color: #484f58; cursor: not-allowed; }
.btn-secondary { background: #21262d; color: #e6edf3; }
.btn-secondary:hover { background: #30363d; }

/* ================================================================ */
/* Steps / progress                                                  */
/* ================================================================ */
.step {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 12px; border-radius: 8px; margin-bottom: 4px;
  font-size: 13px; color: #8b949e; background: #161b22;
}
.step .num { min-width: 22px; height: 22px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 700; background: #21262d; color: #484f58; }
.step.active { color: #e6edf3; background: #1c2128; }
.step.active .num { background: #1f6feb; color: #fff; }
.step.done { color: #3fb950; }
.step.done .num { background: #1a2f1a; color: #3fb950; }
.step.fail { color: #f85149; }
.step.fail .num { background: #2f1a1a; color: #f85149; }
.step .detail { font-size: 11px; color: #8b949e; margin-left: auto; }

/* ================================================================ */
/* Events timeline                                                   */
/* ================================================================ */
.event-item {
  display: flex; gap: 10px; padding: 6px 0; border-bottom: 1px solid #161b22;
  font-size: 12px;
}
.event-item .time { color: #484f58; min-width: 70px; font-family: 'SF Mono', monospace; font-size: 11px; }
.event-item .role-tag {
  display: inline-block; padding: 1px 6px; border-radius: 4px;
  font-size: 10px; font-weight: 600; text-transform: uppercase; min-width: 60px; text-align: center;
}
.event-item .role-tag.creator { background: #1a2f1a; color: #3fb950; }
.event-item .role-tag.buyer { background: #1a1f2f; color: #58a6ff; }
.event-item .role-tag.seeder { background: #2f2a1a; color: #d29922; }
.event-item .role-tag.advertiser { background: #2f1a2f; color: #bc8cff; }
.event-item .type { color: #e6edf3; font-weight: 500; }
.event-item .payload { color: #8b949e; font-family: 'SF Mono', monospace; font-size: 11px; word-break: break-all; }
.event-filter { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
.event-filter button {
  background: #21262d; border: 1px solid #30363d; color: #8b949e;
  padding: 4px 10px; border-radius: 4px; font-size: 11px; cursor: pointer;
}
.event-filter button.active { background: #30363d; color: #e6edf3; border-color: #58a6ff; }

/* ================================================================ */
/* Buy modes                                                         */
/* ================================================================ */
.mode-row { display: flex; gap: 12px; margin: 10px 0; align-items: center; }
.mode-row label { color: #8b949e; font-size: 13px; cursor: pointer; }
.mode-row input[type="radio"] { accent-color: #58a6ff; }

/* ================================================================ */
/* Catalog                                                           */
/* ================================================================ */
.catalog-item {
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 14px; border-radius: 8px; cursor: pointer;
  border: 1px solid transparent; transition: background 0.1s;
}
.catalog-item:hover { background: #1c2128; }
.catalog-item.selected { border-color: #58a6ff; background: #1c2128; }
.catalog-item .name { font-weight: 500; }
.catalog-item .meta { font-size: 12px; color: #8b949e; }
.catalog-item .owned-badge {
  display: inline-block; font-size: 10px; font-weight: 600;
  color: #3fb950; background: #1a2f1a; border: 1px solid #2a4a2a;
  border-radius: 4px; padding: 1px 6px; margin-left: 6px; vertical-align: middle;
}
.catalog-item .pre-badge {
  display: inline-block; font-size: 10px; font-weight: 600;
  color: #a371f7; background: #1f1a2e; border: 1px solid #362b54;
  border-radius: 4px; padding: 1px 6px; margin-left: 6px; vertical-align: middle;
}
.catalog-item .device-badge {
  display: inline-block; font-size: 10px; font-weight: 600;
  color: #f0883e; background: #2a1f0e; border: 1px solid #4a3520;
  border-radius: 4px; padding: 1px 6px; margin-left: 6px; vertical-align: middle;
}

/* ================================================================ */
/* Ad overlay                                                        */
/* ================================================================ */
#adOverlay {
  display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.9); z-index: 1000;
  flex-direction: column; align-items: center; justify-content: center;
}
#adOverlay video { max-width: 80%; max-height: 60%; border-radius: 8px; }
#adTimer { color: #f0883e; font-size: 20px; font-weight: 700; margin-top: 16px; }
#adProgressBar {
  width: 60%; height: 4px; background: #21262d; border-radius: 2px; margin-top: 8px; overflow: hidden;
}
#adProgressBar .fill { height: 100%; background: #f0883e; width: 0; transition: width 1s linear; }

/* ================================================================ */
/* Preview                                                           */
/* ================================================================ */
.preview-container { margin-top: 16px; text-align: center; }
.preview-container audio, .preview-container video { max-width: 100%; border-radius: 8px; }
.preview-container img { max-width: 100%; max-height: 300px; border-radius: 8px; }

/* ================================================================ */
/* Network visualization                                             */
/* ================================================================ */
#tab-network { max-width: 100%; padding: 16px; }
#tab-network .card { max-width: none; }
#networkGraph { position: relative; background: #0d1117; border: 1px solid #21262d; border-radius: 8px; overflow: hidden; }
#networkGraph svg { display: block; width: 100%; height: 100%; }
.net-legend { display: flex; gap: 20px; flex-wrap: wrap; margin-top: 12px; font-size: 12px; color: #8b949e; }
.net-legend-item { display: flex; align-items: center; gap: 6px; }
.net-legend-dot { width: 10px; height: 10px; border-radius: 50%; }
.net-tooltip {
  position: absolute; pointer-events: none; background: #161b22; border: 1px solid #30363d;
  border-radius: 6px; padding: 10px 14px; font-size: 12px; color: #e6edf3; line-height: 1.6;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4); z-index: 100; white-space: nowrap; display: none;
}
.net-tooltip .tt-label { color: #8b949e; }
.net-tooltip .tt-value { color: #e6edf3; font-weight: 600; }
.net-status { font-size: 12px; color: #8b949e; margin-top: 8px; }
</style>
</head>
<body>

<!-- ============================================================== -->
<!-- Header                                                          -->
<!-- ============================================================== -->
<div class="header">
  <h1>CONDUIT</h1>
  <span class="node-id" id="nodeId">connecting...</span>
</div>

<!-- ============================================================== -->
<!-- Wallet bar (always visible)                                     -->
<!-- ============================================================== -->
<div class="wallet-bar" id="walletBar">
  <div class="stat"><span class="stat-label">On-chain:</span> <span class="stat-value btc" id="wOnchain">--</span> <span class="stat-label">sats</span></div>
  <div class="stat"><span class="stat-label">Lightning:</span> <span class="stat-value btc" id="wLightning">--</span> <span class="stat-label">sats</span></div>
  <div class="stat"><span class="stat-label">Channels:</span> <span class="stat-value" id="wChannels">--</span></div>
</div>

<!-- ============================================================== -->
<!-- Tab bar                                                         -->
<!-- ============================================================== -->
<div class="tab-bar" id="tabBar">
  <button class="active" data-tab="wallet">Wallet</button>
  <button data-tab="creator">Creator</button>
  <button data-tab="library">Library</button>
  <button data-tab="collection">Collection</button>
  <button data-tab="seeder">Seeder</button>
  <button data-tab="advertiser">Advertiser</button>
  <button data-tab="network">Network</button>
  <button data-tab="events">Events</button>
  <button data-tab="settings">Settings</button>
</div>

<!-- ============================================================== -->
<!-- TAB: Wallet                                                     -->
<!-- ============================================================== -->
<div class="tab-content active" id="tab-wallet">
  <div class="card">
    <h3>Node Identity</h3>
    <p class="mono" id="walletNodeId">--</p>
  </div>
  <div class="card">
    <h3>On-chain Wallet</h3>
    <div style="display:flex;gap:16px;margin-bottom:12px;">
      <div><span class="stat-label">Total: </span><span class="stat-value btc" id="walletOnchain">--</span> sats</div>
      <div><span class="stat-label">Spendable: </span><span class="stat-value" id="walletSpendable">--</span> sats</div>
    </div>
    <p style="font-size:12px;color:#8b949e;">Funding address (click to copy):</p>
    <p class="mono" id="walletAddress" style="margin-top:4px;cursor:pointer;" onclick="copyAddress()" title="Click to copy">--</p>
    <button class="btn btn-secondary" style="margin-top:8px;font-size:11px;" onclick="fetchAddress()">New Address</button>
  </div>
  <div class="card">
    <h3>Lightning Channels</h3>
    <table id="channelTable">
      <tr><th>Peer</th><th>Capacity</th><th>Outbound</th><th>Inbound</th><th>Status</th></tr>
    </table>
    <p class="empty" id="noChannels">No channels yet</p>
  </div>
</div>

<!-- ============================================================== -->
<!-- TAB: Creator                                                    -->
<!-- ============================================================== -->
<div class="tab-content" id="tab-creator">
  <div class="card">
    <h3>Publish Content</h3>
    <p style="font-size:12px;color:#8b949e;margin-bottom:12px;">
      Register a file for sale. The file must be accessible on the node's filesystem.
    </p>
    <div style="display:flex;gap:8px;align-items:end;flex-wrap:wrap;">
      <div style="flex:1;min-width:200px;">
        <label style="font-size:11px;color:#8b949e;display:block;margin-bottom:4px;">File path (on node)</label>
        <input id="regFilePath" placeholder="/path/to/content.mp4" style="width:100%;background:#0d1117;border:1px solid #30363d;color:#e6edf3;padding:8px 10px;border-radius:6px;font-family:inherit;font-size:13px;">
      </div>
      <div style="width:120px;">
        <label style="font-size:11px;color:#8b949e;display:block;margin-bottom:4px;">Price (sats)</label>
        <input id="regPrice" type="number" min="1" value="50" style="width:100%;background:#0d1117;border:1px solid #30363d;color:#e6edf3;padding:8px 10px;border-radius:6px;font-family:inherit;font-size:13px;">
      </div>
      <button class="btn btn-primary" onclick="registerContent()">Publish</button>
    </div>
    <div id="regStatus" style="margin-top:8px;font-size:12px;color:#8b949e;"></div>
  </div>
  <div class="card">
    <h3>My Catalog <button class="btn btn-secondary" style="float:right;font-size:11px;padding:4px 10px;" onclick="loadCreatorCatalog()">Refresh</button></h3>
    <table id="creatorCatalogTable">
      <tr><th>File</th><th>Price</th><th>Size</th><th>Hash</th></tr>
    </table>
    <p class="empty" id="noCreatorCatalog">No content published yet</p>
  </div>
</div>

<!-- ============================================================== -->
<!-- TAB: Library (Buyer)                                            -->
<!-- ============================================================== -->
<div class="tab-content" id="tab-library">
  <div class="card">
    <h3>Browse Catalog <button class="btn btn-secondary" style="float:right;font-size:11px;padding:4px 10px;" onclick="loadCatalog()">Refresh</button></h3>
    <div id="libraryCatalog">
      <p class="empty" id="noLibraryCatalog">Enter a Registry URL in Settings to browse content</p>
    </div>
  </div>

  <div class="card" id="buyCard" style="display:none;">
    <h3 id="buyTitle">--</h3>
    <p id="buyMeta" style="font-size:12px;color:#8b949e;margin-bottom:8px;">--</p>
    <p class="mono" id="buyHash" style="margin-bottom:12px;">--</p>
    <p style="font-size:11px;color:#484f58;margin-bottom:8px;" id="buyCreatorAddr">--</p>

    <div id="deviceNotice" style="display:none;background:#2a1f0e;border:1px solid #4a3520;border-radius:8px;padding:8px 12px;margin-bottom:8px;font-size:12px;color:#f0883e;">
      This content requires a verified TEE device for playback.
    </div>

    <div class="mode-row">
      <label><input type="radio" name="buyMode" value="pre" checked> PRE</label>
      <label><input type="radio" name="buyMode" value="direct"> Direct</label>
      <label><input type="radio" name="buyMode" value="seeder"> Seeder</label>
      <label><input type="radio" name="buyMode" value="chunked"> Chunked</label>
      <label><input type="radio" name="buyMode" value="ad"> Free (ad)</label>
    </div>

    <div style="display:flex;gap:8px;margin-top:12px;">
      <button class="btn btn-primary" id="buyBtn" disabled>Buy</button>
    </div>

    <!-- Progress steps -->
    <div id="buyProgress" style="display:none;margin-top:16px;"></div>

    <!-- Result -->
    <div id="buyResult" style="display:none;margin-top:12px;padding:12px;border-radius:8px;font-size:13px;"></div>

    <!-- Preview -->
    <div class="preview-container" id="buyPreview" style="display:none;"></div>
  </div>
</div>

<!-- ============================================================== -->
<!-- TAB: Collection                                                  -->
<!-- ============================================================== -->
<div class="tab-content" id="tab-collection">
  <div class="card">
    <h3>My Collection <button class="btn btn-secondary" style="float:right;font-size:11px;padding:4px 10px;" onclick="renderCollection()">Refresh</button></h3>
    <p style="font-size:12px;color:#8b949e;margin-bottom:12px;">Content you have purchased. Stored in your browser.</p>
    <div id="collectionList"></div>
    <p class="empty" id="noCollection">No purchases yet. Buy content from the Library tab.</p>
  </div>
</div>

<!-- ============================================================== -->
<!-- TAB: Seeder                                                     -->
<!-- ============================================================== -->
<div class="tab-content" id="tab-seeder">
  <div class="card">
    <h3>Register Seed</h3>
    <p style="font-size:12px;color:#8b949e;margin-bottom:12px;">
      Register encrypted content to seed. Provide the path to the encrypted file, its hash, and the transport price you want to charge.
    </p>
    <div style="display:flex;gap:8px;align-items:end;flex-wrap:wrap;">
      <div style="flex:1;min-width:200px;">
        <label style="font-size:11px;color:#8b949e;display:block;margin-bottom:4px;">Encrypted file path (on node)</label>
        <input id="seedFilePath" placeholder="/path/to/encrypted.enc" style="width:100%;background:#0d1117;border:1px solid #30363d;color:#e6edf3;padding:8px 10px;border-radius:6px;font-family:inherit;font-size:13px;">
      </div>
      <div style="flex:1;min-width:200px;">
        <label style="font-size:11px;color:#8b949e;display:block;margin-bottom:4px;">Encrypted hash H(E)</label>
        <input id="seedEncHash" placeholder="abcdef1234..." style="width:100%;background:#0d1117;border:1px solid #30363d;color:#e6edf3;padding:8px 10px;border-radius:6px;font-family:inherit;font-size:13px;">
      </div>
      <div style="width:120px;">
        <label style="font-size:11px;color:#8b949e;display:block;margin-bottom:4px;">Transport price (sats)</label>
        <input id="seedPrice" type="number" min="1" value="10" style="width:100%;background:#0d1117;border:1px solid #30363d;color:#e6edf3;padding:8px 10px;border-radius:6px;font-family:inherit;font-size:13px;">
      </div>
      <button class="btn btn-primary" onclick="registerSeed()">Seed</button>
    </div>
    <div id="seedStatus" style="margin-top:8px;font-size:12px;color:#8b949e;"></div>
  </div>
  <div class="card">
    <h3>Active Seeds <button class="btn btn-secondary" style="float:right;font-size:11px;padding:4px 10px;" onclick="loadSeederInfo()">Refresh</button></h3>
    <table id="seederTable">
      <tr><th>File</th><th>Chunks</th><th>Transport Price</th><th>Encrypted Hash</th></tr>
    </table>
    <p class="empty" id="noSeeds">No content being seeded yet</p>
  </div>
</div>

<!-- ============================================================== -->
<!-- TAB: Advertiser                                                 -->
<!-- ============================================================== -->
<div class="tab-content" id="tab-advertiser">
  <div class="card">
    <h3>Advertiser Role</h3>
    <p style="font-size:12px;color:#8b949e;margin-bottom:8px;">
      Run third-party ad campaigns. Advertisers are external parties (brands, businesses)
      who pay to show their ads to buyers in exchange for subsidizing content purchases.
    </p>
    <div id="advStatus" style="margin-top:12px;"></div>
    <div id="advEnableHint" style="display:none;margin-top:8px;">
      <p style="font-size:12px;color:#8b949e;">
        Enable by starting the node with <code style="color:#79c0ff;">--ads-dir /path/to/ads</code>
      </p>
      <p style="font-size:11px;color:#484f58;margin-top:4px;">
        Place ad creatives (mp4, webm, png, jpg) in the directory. A default campaign is auto-created from the first file found.
      </p>
    </div>
  </div>
  <div class="card">
    <h3>My Campaigns <button class="btn btn-secondary" style="float:right;font-size:11px;padding:4px 10px;" onclick="loadAdvertiserInfo()">Refresh</button></h3>
    <table id="advCampaignTable">
      <tr><th>Name</th><th>Subsidy/View</th><th>Budget Used</th><th>Budget Total</th><th>Duration</th><th>Status</th></tr>
    </table>
    <p class="empty" id="noCampaigns">No campaigns yet</p>
  </div>
  <div class="card" id="advStatsCard" style="display:none;">
    <h3>Payment Stats</h3>
    <div style="display:flex;gap:24px;flex-wrap:wrap;">
      <div><span class="stat-label">Total paid: </span><span class="stat-value btc" id="advTotalPaid">0</span> sats</div>
      <div><span class="stat-label">Payments: </span><span class="stat-value" id="advPaymentCount">0</span></div>
    </div>
  </div>
  <div class="card">
    <h3>Advertiser Identity</h3>
    <p style="font-size:12px;color:#8b949e;">Ed25519 Pubkey (for attestation signatures):</p>
    <p class="mono" id="advPubkey">--</p>
  </div>
</div>

<!-- ============================================================== -->
<!-- TAB: Network                                                    -->
<!-- ============================================================== -->
<div class="tab-content" id="tab-network">
  <div class="card">
    <h3>Network Topology</h3>
    <p style="font-size:12px;color:#8b949e;margin-bottom:12px;">
      Lightning channels (solid lines) and content distribution (dashed lines) across all discovered nodes.
    </p>
    <div id="networkGraph" style="height:520px;">
      <div class="net-tooltip" id="netTooltip"></div>
    </div>
    <div class="net-legend" id="netLegend">
      <div class="net-legend-item"><div class="net-legend-dot" style="background:#f0883e;"></div>This Node</div>
      <div class="net-legend-item"><div class="net-legend-dot" style="background:#58a6ff;"></div>Creator</div>
      <div class="net-legend-item"><div class="net-legend-dot" style="background:#3fb950;"></div>Seeder</div>
      <div class="net-legend-item"><div class="net-legend-dot" style="background:#bc8cff;"></div>Advertiser</div>
      <div class="net-legend-item"><div class="net-legend-dot" style="background:#8b949e;"></div>Peer</div>
      <div class="net-legend-item"><span style="display:inline-block;width:24px;border-top:2px solid #8b949e;"></span>Channel</div>
      <div class="net-legend-item"><span style="display:inline-block;width:24px;border-top:2px dashed #30363d;"></span>Seeds content</div>
    </div>
    <div class="net-status" id="netStatus"></div>
  </div>
</div>

<!-- ============================================================== -->
<!-- TAB: Events                                                     -->
<!-- ============================================================== -->
<div class="tab-content" id="tab-events">
  <div class="event-filter" id="eventFilter">
    <button class="active" data-filter="all">All</button>
    <button data-filter="creator">Creator</button>
    <button data-filter="buyer">Buyer</button>
    <button data-filter="seeder">Seeder</button>
    <button data-filter="advertiser">Advertiser</button>
  </div>
  <div id="eventList" style="max-height:600px;overflow-y:auto;"></div>
  <p class="empty" id="noEvents">Waiting for events...</p>
</div>

<!-- ============================================================== -->
<!-- TAB: Settings                                                   -->
<!-- ============================================================== -->
<div class="tab-content" id="tab-settings">
  <div class="settings">
    <h3>Node Connection</h3>
    <div class="row"><label>Node URL</label><input id="settNodeUrl" placeholder="http://localhost:3000"></div>
    <div class="row"><label>Registry</label><input id="settRegistryUrl" placeholder="http://registry-ip:3003"></div>
    <div class="status" id="settStatus">Not connected</div>
    <button class="btn btn-primary" style="margin-top:10px;" onclick="connectNode()">Connect</button>
  </div>

  <div class="card" style="margin-top:16px;">
    <h3>Trusted Device Manufacturers</h3>
    <p style="color:#8b949e;font-size:12px;margin-bottom:12px;">
      Manufacturers on this list can provision TEE devices whose attestation your node will accept.
    </p>
    <div id="trustListContainer"><p class="empty">Loading...</p></div>
    <div style="display:flex;gap:8px;margin-top:12px;">
      <input id="trustPkHex" placeholder="Manufacturer public key (hex)" style="flex:2;background:#0d1117;border:1px solid #30363d;color:#e6edf3;padding:6px 10px;border-radius:6px;font-size:12px;font-family:'SF Mono',monospace;">
      <input id="trustName" placeholder="Name" style="flex:1;background:#0d1117;border:1px solid #30363d;color:#e6edf3;padding:6px 10px;border-radius:6px;font-size:13px;">
      <button class="btn btn-primary" onclick="addTrustedManufacturer()">Add</button>
    </div>
    <div class="status" id="trustStatus" style="margin-top:6px;"></div>
  </div>
</div>

<!-- ============================================================== -->
<!-- Ad overlay                                                      -->
<!-- ============================================================== -->
<div id="adOverlay">
  <video id="adVideo" playsinline></video>
  <div id="adTimer"></div>
  <div id="adProgressBar"><div class="fill" id="adProgressFill"></div></div>
</div>

<!-- ============================================================== -->
<!-- JavaScript                                                      -->
<!-- ============================================================== -->
<script>
// ================================================================
// Service Worker
// ================================================================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

// ================================================================
// State
// ================================================================
let nodeUrl = localStorage.getItem('conduit_nodeUrl') || '';
let registryUrl = localStorage.getItem('conduit_registryUrl') || '';
let nodeInfo = null;
let catalog = [];
let selectedItem = null;
let eventSource = null;
let events = [];
let eventFilter = 'all';
let lastOutputFile = '';
let refreshTimer = null;
let purchases = JSON.parse(localStorage.getItem('conduit_purchases') || '[]');

// Ensure a URL has an http:// prefix (registry creator_address often omits it)
function ensureHttp(addr) {
  if (!addr) return '';
  if (addr.startsWith('http://') || addr.startsWith('https://')) return addr;
  return 'http://' + addr;
}

// Populate settings from storage
document.getElementById('settNodeUrl').value = nodeUrl;
document.getElementById('settRegistryUrl').value = registryUrl;

// ================================================================
// Tabs
// ================================================================
document.querySelectorAll('.tab-bar button').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-bar button').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
    if (btn.dataset.tab === 'network' && !netGraphBuilt) loadNetworkGraph();
  });
});

// ================================================================
// Connect to node
// ================================================================
async function connectNode() {
  nodeUrl = document.getElementById('settNodeUrl').value.trim().replace(/\/+$/, '');
  registryUrl = document.getElementById('settRegistryUrl').value.trim().replace(/\/+$/, '');
  localStorage.setItem('conduit_nodeUrl', nodeUrl);
  localStorage.setItem('conduit_registryUrl', registryUrl);

  if (!nodeUrl) {
    document.getElementById('settStatus').textContent = 'Enter a Node URL';
    return;
  }

  document.getElementById('settStatus').textContent = 'Connecting...';
  try {
    const r = await fetch(nodeUrl + '/api/info');
    nodeInfo = await r.json();
    document.getElementById('settStatus').textContent = 'Connected';
    document.getElementById('settStatus').className = 'status ok';
    updateWallet();
    fetchAddress();
    connectSSE();
    loadCatalog();
    loadCreatorCatalog();
    renderCollection();
    loadAdvertiserInfo();
    loadSeederInfo();
    loadTrustList();
    startAutoRefresh();
  } catch (e) {
    document.getElementById('settStatus').textContent = 'Failed: ' + e.message;
    document.getElementById('settStatus').className = 'status';
  }
}

// ================================================================
// Trusted Manufacturers
// ================================================================
async function loadTrustList() {
  if (!nodeUrl) return;
  try {
    const r = await fetch(nodeUrl + '/api/trusted-manufacturers');
    const data = await r.json();
    const items = data.items || [];
    const container = document.getElementById('trustListContainer');
    if (!items.length) {
      container.innerHTML = '<p class="empty">No trusted manufacturers yet</p>';
      return;
    }
    let html = '<table><tr><th>Name</th><th>Public Key</th><th></th></tr>';
    items.forEach(m => {
      html += `<tr>
        <td>${m.name}</td>
        <td class="mono">${m.pk_hex.slice(0, 20)}...${m.pk_hex.slice(-8)}</td>
        <td><button class="btn" style="padding:2px 8px;font-size:11px;" onclick="removeTrustedManufacturer('${m.pk_hex}')">Remove</button></td>
      </tr>`;
    });
    html += '</table>';
    container.innerHTML = html;
  } catch (e) {
    document.getElementById('trustListContainer').innerHTML = '<p class="empty">Failed to load: ' + e.message + '</p>';
  }
}

async function addTrustedManufacturer() {
  const pk = document.getElementById('trustPkHex').value.trim();
  const name = document.getElementById('trustName').value.trim();
  const status = document.getElementById('trustStatus');
  if (!pk || !name) { status.textContent = 'Both fields required'; status.style.color = '#f85149'; return; }
  if (!nodeUrl) { status.textContent = 'Connect to node first'; status.style.color = '#f85149'; return; }
  try {
    const r = await fetch(nodeUrl + '/api/trusted-manufacturers', {
      method: 'POST', headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ pk_hex: pk, name: name })
    });
    const data = await r.json();
    if (r.ok) {
      status.textContent = 'Added'; status.style.color = '#3fb950';
      document.getElementById('trustPkHex').value = '';
      document.getElementById('trustName').value = '';
      loadTrustList();
    } else {
      status.textContent = data.error || 'Failed'; status.style.color = '#f85149';
    }
  } catch (e) {
    status.textContent = 'Error: ' + e.message; status.style.color = '#f85149';
  }
}

async function removeTrustedManufacturer(pkHex) {
  if (!nodeUrl) return;
  try {
    await fetch(nodeUrl + '/api/trusted-manufacturers/' + pkHex, { method: 'DELETE' });
    loadTrustList();
  } catch (e) {}
}

// ================================================================
// Auto-refresh (balance + catalogs every 30s)
// ================================================================
function startAutoRefresh() {
  if (refreshTimer) clearInterval(refreshTimer);
  refreshTimer = setInterval(async () => {
    if (!nodeUrl) return;
    try {
      const r = await fetch(nodeUrl + '/api/info');
      nodeInfo = await r.json();
      updateWallet();
    } catch (e) {}
  }, 30000);
}

// ================================================================
// Wallet
// ================================================================
async function updateWallet() {
  if (!nodeInfo) return;
  document.getElementById('nodeId').textContent = nodeInfo.node_id.slice(0, 12) + '...';
  document.getElementById('walletNodeId').textContent = nodeInfo.node_id;
  document.getElementById('wOnchain').textContent = (nodeInfo.onchain_balance_sats || 0).toLocaleString();
  document.getElementById('wLightning').textContent = (nodeInfo.lightning_balance_sats || 0).toLocaleString();
  document.getElementById('walletOnchain').textContent = (nodeInfo.onchain_balance_sats || 0).toLocaleString();
  document.getElementById('walletSpendable').textContent = (nodeInfo.spendable_onchain_sats || 0).toLocaleString();

  const channels = nodeInfo.channels || [];
  document.getElementById('wChannels').textContent = channels.length + ' (' + channels.filter(c => c.usable).length + ' usable)';

  const table = document.getElementById('channelTable');
  while (table.rows.length > 1) table.deleteRow(1);
  document.getElementById('noChannels').style.display = channels.length ? 'none' : 'block';
  channels.forEach(ch => {
    const row = table.insertRow();
    row.innerHTML = `
      <td class="mono">${(ch.counterparty_node_id || '--').slice(0, 16)}...</td>
      <td class="price">${(ch.channel_value_sats || ch.value_sats || 0).toLocaleString()} sats</td>
      <td>${Math.round((ch.outbound_capacity_msat || ch.outbound_msat || 0) / 1000).toLocaleString()} sats</td>
      <td>${Math.round((ch.inbound_capacity_msat || ch.inbound_msat || 0) / 1000).toLocaleString()} sats</td>
      <td><span class="badge ${ch.usable ? 'badge-green' : 'badge-yellow'}">${ch.usable ? 'Usable' : ch.is_channel_ready || ch.ready ? 'Ready' : 'Pending'}</span></td>
    `;
  });
}

async function fetchAddress() {
  if (!nodeUrl) return;
  try {
    const r = await fetch(nodeUrl + '/api/address');
    const data = await r.json();
    if (data.address) {
      document.getElementById('walletAddress').textContent = data.address;
    }
  } catch (e) {
    document.getElementById('walletAddress').textContent = 'Failed to fetch address';
  }
}

function copyAddress() {
  const addr = document.getElementById('walletAddress').textContent;
  if (!addr || addr === '--' || addr.startsWith('Failed')) return;
  navigator.clipboard.writeText(addr).then(() => {
    const el = document.getElementById('walletAddress');
    const orig = el.textContent;
    el.textContent = 'Copied!';
    el.style.color = '#3fb950';
    setTimeout(() => { el.textContent = orig; el.style.color = ''; }, 1500);
  });
}

// ================================================================
// SSE events (history backfill then live stream)
// ================================================================
async function connectSSE() {
  if (eventSource) eventSource.close();
  // Backfill from persistent log (oldest-first from API; prepend in reverse so newest at top)
  try {
    const r = await fetch(nodeUrl + '/api/events/history?limit=500');
    const history = await r.json();
    if (Array.isArray(history) && history.length) {
      for (let i = history.length - 1; i >= 0; i--) {
        const ev = history[i];
        events.unshift(ev);
        renderEvent(ev);
      }
      if (events.length > 500) events.splice(500);
    }
  } catch (e) {}
  eventSource = new EventSource(nodeUrl + '/api/events');
  eventSource.onmessage = (msg) => {
    try {
      const ev = JSON.parse(msg.data);
      events.unshift(ev);
      if (events.length > 500) events.pop();
      renderEvent(ev);
      handleBuyerEvent(ev);
      handleCreatorEvent(ev);
    } catch (e) {}
  };
  eventSource.onerror = () => {
    document.getElementById('nodeId').textContent = 'SSE disconnected — reconnecting...';
  };
}

function renderEvent(ev) {
  if (eventFilter !== 'all' && ev.role !== eventFilter) return;
  document.getElementById('noEvents').style.display = 'none';
  const list = document.getElementById('eventList');
  const div = document.createElement('div');
  div.className = 'event-item';
  const ts = ev.timestamp ? ev.timestamp.split('T').pop().split('.')[0] || ev.timestamp : '';
  div.innerHTML = `
    <span class="time">${ts}</span>
    <span class="role-tag ${ev.role || ''}">${ev.role || '?'}</span>
    <span class="type">${ev.event_type || ''}</span>
    <span class="payload">${JSON.stringify(ev.data || {}).slice(0, 120)}</span>
  `;
  list.prepend(div);
}

// Event filter buttons
document.querySelectorAll('#eventFilter button').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#eventFilter button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    eventFilter = btn.dataset.filter;
    document.getElementById('eventList').innerHTML = '';
    document.getElementById('noEvents').style.display = events.length ? 'none' : 'block';
    events.forEach(ev => renderEvent(ev));
  });
});

// ================================================================
// Creator: register content
// ================================================================
async function registerContent() {
  const filePath = document.getElementById('regFilePath').value.trim();
  const price = parseInt(document.getElementById('regPrice').value, 10);
  const statusEl = document.getElementById('regStatus');

  if (!filePath) { statusEl.textContent = 'File path is required'; statusEl.style.color = '#f85149'; return; }
  if (!price || price < 1) { statusEl.textContent = 'Price must be at least 1 sat'; statusEl.style.color = '#f85149'; return; }
  if (!nodeUrl) { statusEl.textContent = 'Connect to a node first (Settings tab)'; statusEl.style.color = '#f85149'; return; }

  statusEl.textContent = 'Registering...';
  statusEl.style.color = '#8b949e';

  try {
    const r = await fetch(nodeUrl + '/api/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ file: filePath, price: price }),
    });
    const data = await r.json();
    if (data.error) {
      statusEl.textContent = 'Error: ' + data.error;
      statusEl.style.color = '#f85149';
    } else {
      statusEl.textContent = 'Registration started — encrypting and cataloging...';
      statusEl.style.color = '#3fb950';
      // Refresh catalog after a short delay to pick up the new entry
      setTimeout(() => loadCreatorCatalog(), 3000);
    }
  } catch (e) {
    statusEl.textContent = 'Failed: ' + e.message;
    statusEl.style.color = '#f85149';
  }
}

// Handle creator SSE events (auto-refresh catalog on REGISTERED)
function handleCreatorEvent(ev) {
  if (ev.event_type === 'REGISTERED' || ev.event_type === 'ALREADY_REGISTERED') {
    loadCreatorCatalog();
  }
}

// ================================================================
// Creator catalog display
// ================================================================
async function loadCreatorCatalog() {
  if (!nodeUrl) return;
  try {
    const r = await fetch(nodeUrl + '/api/catalog');
    const data = await r.json();
    const allItems = data.items || data.catalog || (Array.isArray(data) ? data : []);
    // Creator entries have price_sats > 0 or a non-empty content_hash; exclude seeder-only entries
    const items = allItems.filter(i => (i.price_sats && i.price_sats > 0) || (i.content_hash && i.content_hash.length > 0));
    const table = document.getElementById('creatorCatalogTable');
    while (table.rows.length > 1) table.deleteRow(1);
    document.getElementById('noCreatorCatalog').style.display = items.length ? 'none' : 'block';
    items.forEach(item => {
      const row = table.insertRow();
      row.innerHTML = `
        <td>${item.file_name || '--'}</td>
        <td class="price">${item.price_sats || 0} sats</td>
        <td>${fmtSize(item.size_bytes || 0)}</td>
        <td class="mono" title="${item.content_hash || ''}">${(item.content_hash || '').slice(0, 16)}...</td>
      `;
    });
  } catch (e) {}
}

// ================================================================
// Library (buyer catalog from registry)
// ================================================================
async function loadCatalog() {
  if (!registryUrl) {
    document.getElementById('noLibraryCatalog').textContent = 'Enter a Registry URL in Settings to browse content';
    return;
  }
  document.getElementById('noLibraryCatalog').textContent = 'Loading...';
  try {
    const r = await fetch(registryUrl + '/api/listings');
    const data = await r.json();
    // Registry returns { items: [...] }
    catalog = data.items || data.listings || (Array.isArray(data) ? data : []);
    renderCatalog();
  } catch (e) {
    document.getElementById('noLibraryCatalog').textContent = 'Failed to load catalog: ' + e.message;
  }
}

function isPurchased(contentHash) {
  return purchases.some(p => p.content_hash === contentHash);
}

function renderCatalog() {
  const container = document.getElementById('libraryCatalog');
  container.innerHTML = '';
  if (!catalog.length) {
    container.innerHTML = '<p class="empty">No content available on registry</p>';
    return;
  }
  catalog.forEach(item => {
    const div = document.createElement('div');
    div.className = 'catalog-item' + (selectedItem && selectedItem.content_hash === item.content_hash ? ' selected' : '');
    const ext = (item.file_name || '').split('.').pop().toUpperCase();
    let creator = '';
    if (item.creator_address) {
      try { creator = ' from ' + new URL(ensureHttp(item.creator_address)).hostname; }
      catch { creator = ' from ' + item.creator_address.replace(/:\d+$/, ''); }
    }
    const owned = isPurchased(item.content_hash) ? '<span class="owned-badge">OWNED</span>' : '';
    const pre = item.pre_c1_hex ? '<span class="pre-badge">PRE</span>' : '';
    const device = (item.playback_policy === 'device_required' || item.playback_policy === 'device_recommended')
      ? '<span class="device-badge">DEVICE</span>' : '';
    div.innerHTML = `
      <div>
        <div class="name">${item.file_name || 'Unknown'}${pre}${device}${owned}</div>
        <div class="meta">${ext} &middot; ${fmtSize(item.size_bytes || 0)}${creator}</div>
      </div>
      <div class="price">${item.price_sats || 0} sats</div>
    `;
    div.addEventListener('click', () => selectItem(item));
    container.appendChild(div);
  });
}

function selectItem(item) {
  selectedItem = item;
  renderCatalog();
  document.getElementById('buyCard').style.display = 'block';
  document.getElementById('buyTitle').textContent = item.file_name || 'Unknown';
  document.getElementById('buyMeta').textContent = `${fmtSize(item.size_bytes || 0)} | ${item.price_sats || 0} sats`;
  document.getElementById('buyHash').textContent = item.content_hash || '';
  document.getElementById('buyCreatorAddr').textContent = item.creator_address ? 'Creator: ' + item.creator_address : '';
  document.getElementById('buyBtn').disabled = false;
  document.getElementById('buyProgress').style.display = 'none';
  document.getElementById('buyProgress').innerHTML = '';
  document.getElementById('buyResult').style.display = 'none';
  document.getElementById('buyPreview').style.display = 'none';
  // Auto-select PRE mode if item is PRE-enabled, otherwise default to Direct
  const defaultMode = item.pre_c1_hex ? 'pre' : 'direct';
  const radio = document.querySelector(`input[name="buyMode"][value="${defaultMode}"]`);
  if (radio) radio.checked = true;
  // Show device notice for TEE-required content
  const notice = document.getElementById('deviceNotice');
  if (item.playback_policy === 'device_required') {
    notice.textContent = 'This content requires a verified TEE device for playback.';
    notice.style.display = 'block';
  } else if (item.playback_policy === 'device_recommended') {
    notice.textContent = 'This content is best viewed on a verified TEE device.';
    notice.style.display = 'block';
  } else {
    notice.style.display = 'none';
  }
}

// ================================================================
// Buy flow
// ================================================================
document.getElementById('buyBtn').addEventListener('click', doBuy);

function getMode() {
  return document.querySelector('input[name="buyMode"]:checked').value;
}

async function doBuy() {
  if (!selectedItem) return;

  if (isPurchased(selectedItem.content_hash)) {
    if (!confirm('You already own this asset. Purchase again?')) return;
  }

  const mode = getMode();
  document.getElementById('buyBtn').disabled = true;
  document.getElementById('buyResult').style.display = 'none';
  document.getElementById('buyPreview').style.display = 'none';

  if (mode === 'pre') await doBuyPre();
  else if (mode === 'direct') await doBuyDirect();
  else if (mode === 'ad') await doBuyAdSubsidized();
  else await doBuyChunked(mode);
}

// Progress step helpers
function buildSteps(steps) {
  const container = document.getElementById('buyProgress');
  container.innerHTML = '';
  container.style.display = 'block';
  steps.forEach((s, i) => {
    const div = document.createElement('div');
    div.className = 'step';
    div.id = 'step-' + s.id;
    div.innerHTML = `<span class="num">${i + 1}</span><span class="text">${s.text}</span><span class="detail"></span>`;
    container.appendChild(div);
  });
}

function setStep(id, state, detail) {
  const el = document.getElementById('step-' + id);
  if (!el) return;
  el.className = 'step ' + state;
  if (detail !== undefined) el.querySelector('.detail').textContent = detail;
}

function showResult(ok, msg) {
  const el = document.getElementById('buyResult');
  el.style.display = 'block';
  el.style.background = ok ? '#1a2f1a' : '#2f1a1a';
  el.style.color = ok ? '#3fb950' : '#f85149';
  el.textContent = msg;
  document.getElementById('buyBtn').disabled = false;
}

// --- PRE buy ---
const STEPS_PRE = [
  { id: 'preinfo', text: 'Getting buyer PRE public key' },
  { id: 'prepurchase', text: 'Requesting PRE invoice from creator' },
  { id: 'pay', text: 'Paying Lightning invoice' },
  { id: 'htlc', text: 'HTLC settling (preimage = SHA-256(rk))' },
  { id: 'prekey', text: 'Recovering AES key via PRE' },
  { id: 'fetch', text: 'Downloading encrypted chunks' },
  { id: 'decrypt', text: 'Decrypting with recovered key' },
  { id: 'verify', text: 'Verifying plaintext H(F)' },
];

async function doBuyPre() {
  buildSteps(STEPS_PRE);

  const creatorUrl = ensureHttp(selectedItem.creator_address);
  if (!creatorUrl) {
    showResult(false, 'No creator address available for this listing');
    return;
  }

  if (!nodeUrl) {
    showResult(false, 'Set your node URL first (Settings tab)');
    return;
  }

  // Step 1: Get buyer's PRE public key from local node
  setStep('preinfo', 'active', 'Fetching G2 public key...');
  let buyerPkHex;
  try {
    const r = await fetch(nodeUrl + '/api/pre-info');
    const info = await r.json();
    buyerPkHex = info.buyer_pk_hex;
    if (!buyerPkHex) throw new Error('No buyer_pk_hex in response');
    setStep('preinfo', 'done', 'G2 pk: ' + buyerPkHex.substring(0, 16) + '...');
  } catch (e) {
    setStep('preinfo', 'fail', e.message);
    showResult(false, 'Failed to get buyer PRE key. Is your node running the PRE build?');
    return;
  }

  // Step 2: Call creator /api/pre-purchase with buyer pk
  setStep('prepurchase', 'active', 'Contacting creator...');
  try {
    const outputFile = '/tmp/decrypted-pre-' + Date.now() + '-' + (selectedItem.file_name || 'content');
    lastOutputFile = outputFile.split('/').pop();

    // Determine seeder URL (if available from registry)
    let seederUrl = null;
    if (registryUrl) {
      try {
        const dr = await fetch(registryUrl + '/api/discover/' + selectedItem.content_hash);
        const dd = await dr.json();
        if (dd.seeders && dd.seeders.length > 0) {
          seederUrl = ensureHttp(dd.seeders[0].address);
        }
      } catch (_) { /* no seeder, fall back to creator */ }
    }

    setStep('prepurchase', 'done', selectedItem.price_sats + ' sats');

    // Step 3: Trigger PRE buy on local node (it handles everything)
    setStep('pay', 'active', 'Initiating PRE payment...');
    const r = await fetch(nodeUrl + '/api/buy-pre', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        creator_url: creatorUrl,
        content_hash: selectedItem.content_hash,
        seeder_url: seederUrl,
        output: outputFile,
      }),
    });
    const res = await r.json();
    console.log('PRE buy started:', res);
    // SSE events will drive the remaining step updates
  } catch (e) {
    setStep('prepurchase', 'fail', e.message);
    showResult(false, 'PRE purchase failed: ' + e.message);
  }
}

// --- Direct buy ---
const STEPS_DIRECT = [
  { id: 'invoice', text: 'Requesting invoice from creator' },
  { id: 'pay', text: 'Paying creator invoice' },
  { id: 'htlc', text: 'HTLC settling' },
  { id: 'fetch', text: 'Fetching encrypted content' },
  { id: 'decrypt', text: 'Decrypting with K' },
  { id: 'verify', text: 'Verifying plaintext H(F)' },
];

async function doBuyDirect() {
  buildSteps(STEPS_DIRECT);

  const creatorUrl = ensureHttp(selectedItem.creator_address);
  if (!creatorUrl) {
    showResult(false, 'No creator address available for this listing');
    return;
  }

  // Step 1: Request invoice from creator
  setStep('invoice', 'active', 'Contacting creator...');
  let invoiceData;
  try {
    const r = await fetch(creatorUrl + '/api/invoice/' + selectedItem.content_hash, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({}),
    });
    invoiceData = await r.json();
    if (invoiceData.error) {
      setStep('invoice', 'fail', invoiceData.error);
      showResult(false, invoiceData.error);
      return;
    }
    setStep('invoice', 'done', invoiceData.price_sats + ' sats');
  } catch (e) {
    setStep('invoice', 'fail', e.message);
    showResult(false, 'Failed to get invoice: ' + e.message);
    return;
  }

  // Step 2: Pay invoice via local buyer node
  setStep('pay', 'active', 'Sending payment...');
  const encUrl = creatorUrl + '/api/enc/' + (invoiceData.enc_filename || '');
  const outputFile = '/tmp/decrypted-' + Date.now() + '-' + (invoiceData.file_name || 'content');
  lastOutputFile = outputFile.split('/').pop();

  try {
    const r = await fetch(nodeUrl + '/api/buy', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        invoice: invoiceData.bolt11,
        enc_url: encUrl,
        hash: invoiceData.content_hash,
        output: outputFile,
      }),
    });
    const res = await r.json();
    console.log('Direct buy started:', res);
    // SSE events will update the remaining steps
  } catch (e) {
    setStep('pay', 'fail', e.message);
    showResult(false, 'Failed: ' + e.message);
  }
}

// --- Chunked / seeder buy ---
const STEPS_CHUNKED = [
  { id: 'invoice', text: 'Requesting invoice from creator' },
  { id: 'cpay', text: 'Paying creator (content key K)' },
  { id: 'chtlc', text: 'Content HTLC settling' },
  { id: 'cmeta', text: 'Fetching chunk metadata' },
  { id: 'cbit', text: 'Querying seeder bitfields' },
  { id: 'tpay', text: 'Paying seeders (transport)' },
  { id: 'thtlc', text: 'Transport HTLC settling' },
  { id: 'down', text: 'Downloading & verifying chunks' },
  { id: 'assem', text: 'Reassembling content' },
  { id: 'decrypt', text: 'Decrypting with K' },
  { id: 'verify', text: 'Verifying plaintext H(F)' },
];

async function doBuyChunked(mode) {
  buildSteps(STEPS_CHUNKED);

  const creatorUrl = ensureHttp(selectedItem.creator_address);
  if (!creatorUrl) {
    showResult(false, 'No creator address available for this listing');
    return;
  }

  // Step 1: Request invoice from creator
  setStep('invoice', 'active', 'Contacting creator...');
  let invoiceData;
  try {
    const r = await fetch(creatorUrl + '/api/invoice/' + selectedItem.content_hash, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({}),
    });
    invoiceData = await r.json();
    if (invoiceData.error) {
      setStep('invoice', 'fail', invoiceData.error);
      showResult(false, invoiceData.error);
      return;
    }
    setStep('invoice', 'done', invoiceData.price_sats + ' sats');
  } catch (e) {
    setStep('invoice', 'fail', e.message);
    showResult(false, 'Failed to get invoice: ' + e.message);
    return;
  }

  setStep('cpay', 'active', 'Starting...');

  // Discover seeders from registry
  let seederUrls = [];
  if (mode === 'seeder' || mode === 'chunked') {
    try {
      const dr = await fetch(registryUrl + '/api/discover/' + selectedItem.content_hash);
      const dd = await dr.json();
      seederUrls = (dd.seeders || dd.items || []).map(s => ensureHttp(s.seeder_address)).filter(Boolean);
    } catch (e) {}
    if (seederUrls.length === 0) {
      showResult(false, 'No seeders found for this content. Try Direct mode instead.');
      return;
    }
  }

  const body = {
    mode: mode,
    content_invoice: invoiceData.bolt11,
    encrypted_hash: invoiceData.encrypted_hash || selectedItem.encrypted_hash || '',
    hash: selectedItem.content_hash,
    output: '/tmp/decrypted-' + Date.now() + '-' + (selectedItem.file_name || 'content'),
    seeder_urls: seederUrls,
  };
  try {
    const r = await fetch(nodeUrl + '/api/buy', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    const res = await r.json();
    console.log('Buy started:', res);
  } catch (e) {
    setStep('cpay', 'fail', e.message);
    showResult(false, 'Failed: ' + e.message);
  }
}

// --- Ad-subsidized buy (two-payment flow) ---
const STEPS_AD = [
  { id: 'adinv', text: 'Requesting ad-subsidized invoices' },
  { id: 'adwatch', text: 'Watching sponsored ad' },
  { id: 'adattest', text: 'Obtaining attestation token' },
  { id: 'keypay', text: 'Buyer paying 1 sat (learn K)' },
  { id: 'keyhtlc', text: 'Key HTLC settling' },
  { id: 'adpay', text: 'Advertiser paying content price' },
  { id: 'adhtlc', text: 'Subsidy HTLC settling' },
  { id: 'fetch', text: 'Fetching encrypted content' },
  { id: 'decrypt', text: 'Decrypting with K' },
  { id: 'verify', text: 'Verifying plaintext H(F)' },
];

async function doBuyAdSubsidized() {
  buildSteps(STEPS_AD);

  const creatorUrl = ensureHttp(selectedItem.creator_address);
  if (!creatorUrl) {
    showResult(false, 'No creator address for this listing');
    return;
  }

  // Prompt for advertiser URL
  const advertiserUrl = prompt('Enter advertiser node URL (e.g. http://ip:port):', '');
  if (!advertiserUrl) { showResult(false, 'Advertiser URL required'); return; }

  setStep('adinv', 'active', 'Requesting invoices from creator...');

  let adInvoice;
  try {
    const r = await fetch(creatorUrl + '/api/ad-invoice/' + selectedItem.content_hash, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ advertiser_url: advertiserUrl }),
    });
    adInvoice = await r.json();
    if (adInvoice.error) { setStep('adinv', 'fail', adInvoice.error); showResult(false, adInvoice.error); return; }
  } catch (e) { setStep('adinv', 'fail', e.message); showResult(false, e.message); return; }

  setStep('adinv', 'done', 'Two invoices received (1 sat + ' + adInvoice.price_sats + ' sats)');

  let buyerNodeId = '';
  try {
    const ir = await fetch(nodeUrl + '/api/info');
    const id = await ir.json();
    buyerNodeId = id.node_id || '';
  } catch (e) {}

  // Start ad session
  setStep('adwatch', 'active', 'Starting ad session...');
  let sessionData;
  try {
    const r = await fetch(advertiserUrl + '/api/campaigns/' + adInvoice.campaign_id + '/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ buyer_pubkey: buyerNodeId }),
    });
    sessionData = await r.json();
    if (sessionData.error) { setStep('adwatch', 'fail', sessionData.error); showResult(false, sessionData.error); return; }
  } catch (e) { setStep('adwatch', 'fail', e.message); showResult(false, e.message); return; }

  // Display ad with countdown
  const overlay = document.getElementById('adOverlay');
  const video = document.getElementById('adVideo');
  const timer = document.getElementById('adTimer');
  const fill = document.getElementById('adProgressFill');
  overlay.style.display = 'flex';
  const dMs = sessionData.duration_ms || 15000;
  const dSec = Math.ceil(dMs / 1000);
  video.src = advertiserUrl + '/api/campaigns/' + adInvoice.campaign_id + '/creative';
  video.play().catch(() => {});
  let rem = dSec;
  timer.textContent = rem + 's';
  fill.style.width = '0%';

  await new Promise(resolve => {
    const iv = setInterval(() => {
      rem--;
      timer.textContent = rem > 0 ? rem + 's' : 'Done!';
      fill.style.width = Math.min(100, ((dSec - rem) / dSec) * 100) + '%';
      setStep('adwatch', 'active', rem > 0 ? rem + 's remaining' : 'Complete');
      if (rem <= 0) { clearInterval(iv); resolve(); }
    }, 1000);
  });
  video.pause();
  overlay.style.display = 'none';
  setStep('adwatch', 'done', 'Ad viewed (' + dSec + 's)');

  // Get attestation token
  setStep('adattest', 'active', 'Requesting token...');
  let attestation;
  try {
    const r = await fetch(advertiserUrl + '/api/campaigns/' + adInvoice.campaign_id + '/complete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionData.session_id, buyer_pubkey: buyerNodeId }),
    });
    attestation = await r.json();
    if (attestation.error) { setStep('adattest', 'fail', attestation.error); showResult(false, attestation.error); return; }
  } catch (e) { setStep('adattest', 'fail', e.message); showResult(false, e.message); return; }
  setStep('adattest', 'done', 'Token received');

  // Payment 1: Buyer pays 1 sat to learn K
  setStep('keypay', 'active', 'Paying 1 sat...');
  const encFilename = adInvoice.enc_filename || '';
  const encUrl = creatorUrl + '/api/enc/' + encFilename;
  const baseName = (adInvoice.file_name || 'content').replace(/\.[^.]+$/, '');
  const ext = (adInvoice.file_name || '').split('.').pop() || 'bin';
  const outputFile = 'decrypted-' + Date.now() + '-' + baseName + '.' + ext;
  lastOutputFile = outputFile;

  try {
    const r = await fetch(nodeUrl + '/api/buy', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        invoice: adInvoice.buyer_invoice,
        enc_url: encUrl,
        hash: adInvoice.content_hash,
        output: '/tmp/' + outputFile,
      }),
    });
    const res = await r.json();
    console.log('Ad buy Payment 1 (key) started:', res);
  } catch (e) { setStep('keypay', 'fail', e.message); showResult(false, e.message); return; }

  // Payment 2: Advertiser pays content price (K_ad, not K)
  setStep('adpay', 'active', 'Advertiser paying ' + adInvoice.price_sats + ' sats...');
  try {
    const r = await fetch(advertiserUrl + '/api/campaigns/pay', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        bolt11_invoice: adInvoice.advertiser_invoice,
        attestation_token: attestation.token,
        attestation_payload: attestation.payload,
      }),
    });
    const res = await r.json();
    if (res.status !== 'payment_sent') {
      setStep('adpay', 'fail', res.status || 'Unknown error');
    } else {
      setStep('adpay', 'done', 'Subsidy paid (K_ad, not K)');
      setStep('adhtlc', 'active', 'Settling...');
    }
  } catch (e) { setStep('adpay', 'fail', e.message); }
}

// ================================================================
// Handle SSE events for buy progress
// ================================================================
function handleBuyerEvent(ev) {
  const mode = getMode();
  switch (ev.event_type) {

    // ---- PRE-specific events ----
    case 'PRE_BUY_START':
      setStep('pay', 'active', 'Contacting creator...');
      break;
    case 'PRE_PURCHASE_RECEIVED':
      setStep('prepurchase', 'done', (ev.data.price_sats || '?') + ' sats');
      setStep('pay', 'active', 'Paying invoice...');
      break;
    case 'PRE_PAYMENT_CONFIRMED':
      setStep('htlc', 'done', 'Preimage = SHA-256(rk)');
      setStep('prekey', 'active', 'Decrypting via PRE...');
      break;
    case 'PRE_KEY_RECOVERED':
      setStep('prekey', 'done', 'AES key recovered');
      setStep('fetch', 'active', 'Downloading chunks...');
      break;
    case 'DOWNLOADING_CHUNKS':
      setStep('fetch', 'active', (ev.data.chunks || '?') + ' chunks from ' + (ev.data.source || 'seeder'));
      break;
    case 'CHUNKS_DOWNLOADED':
      setStep('fetch', 'done', fmtSize(ev.data.total_bytes || 0));
      setStep('decrypt', 'active', 'Decrypting...');
      break;

    // ---- General events ----
    case 'FETCHING_ENC':
      setStep('fetch', 'active', 'Downloading...'); break;
    case 'ENC_FETCHED':
      setStep('fetch', 'done', fmtSize(ev.data.bytes || 0)); break;
    case 'FETCH_FAILED':
      setStep('fetch', 'fail', ev.data.error || 'Failed'); showResult(false, 'Download failed'); break;
    case 'BUY_ERROR':
      showResult(false, ev.data.message || 'Error'); break;
    case 'COUNTDOWN':
      if (mode === 'ad') setStep('keypay', 'active', ev.data.message || '');
      else setStep('pay', 'active', ev.data.message || '');
      break;

    case 'PAYING_INVOICE':
      if (mode === 'ad') setStep('keypay', 'active', '1 sat invoice sent');
      else setStep('pay', 'active', 'Invoice sent');
      break;
    case 'PAYMENT_SENT':
      if (mode === 'ad') { setStep('keypay', 'done', 'HTLC in flight'); setStep('keyhtlc', 'active'); }
      else { setStep('pay', 'done', 'HTLC in flight'); setStep('htlc', 'active'); }
      break;
    case 'PAYMENT_CONFIRMED':
      if (mode === 'ad') { setStep('keyhtlc', 'done', 'K received'); setStep('fetch', 'active'); }
      else { setStep('htlc', 'done', 'Preimage received'); setStep('fetch', 'active'); }
      break;
    case 'PAYMENT_FAILED':
      if (mode === 'ad') setStep('keypay', 'fail', ev.data.reason || 'Failed');
      else setStep('pay', 'fail', ev.data.reason || 'Failed');
      showResult(false, 'Payment failed');
      break;

    // Ad-specific hold-and-claim events
    case 'AD_HTLC_BUYER_ARRIVED': setStep('keyhtlc', 'done', 'Buyer HTLC held'); break;
    case 'AD_HTLC_ADVERTISER_ARRIVED': setStep('adhtlc', 'done', 'Ad HTLC held'); break;
    case 'AD_BOTH_HTLCS_READY': setStep('adhtlc', 'done', 'Both HTLCs — claiming'); break;
    case 'AD_CLAIMED_BUYER': setStep('keyhtlc', 'done', 'K revealed — decrypting'); setStep('fetch', 'active'); break;
    case 'AD_CLAIMED_ADVERTISER': setStep('adhtlc', 'done', 'K_ad claimed (meaningless)'); break;

    case 'DECRYPTING': setStep('decrypt', 'active', 'Decrypting...'); break;
    case 'DECRYPTED':
    case 'CONTENT_DECRYPTED':
      setStep('decrypt', 'done', ev.data.chunks ? ev.data.chunks + ' chunks' : 'Decrypted');
      setStep('verify', 'active', 'Verifying...');
      break;
    case 'VERIFYING': setStep('verify', 'active', 'Verifying...'); break;
    case 'VERIFIED':
    case 'HASH_VERIFIED':
      if (ev.data.matches === false) {
        setStep('verify', 'fail', 'Mismatch!');
        showResult(false, 'Verification failed — content hash mismatch');
      } else {
        setStep('verify', 'done', 'Verified');
      }
      break;
    case 'HASH_MISMATCH':
    case 'VERIFICATION_FAILED': setStep('verify', 'fail', 'Mismatch!'); showResult(false, 'Verification failed'); break;

    // Chunked mode decrypt/verify
    case 'CHUNKS_DECRYPTED':
      setStep('decrypt', 'done', ev.data.chunk_count ? ev.data.chunk_count + ' chunks' : 'Decrypted');
      setStep('verify', 'active', 'Verifying...');
      break;

    case 'FILE_SAVED':
      showResult(true, 'Content purchased and verified!');
      tryPreview(ev.data);
      recordPurchase(ev.data);
      break;

    // Chunked mode events — creator payment
    case 'CONTENT_PAYING': setStep('cpay', 'active', 'Sending payment...'); break;
    case 'CONTENT_PAYMENT_SENT': setStep('cpay', 'done', 'HTLC in flight'); setStep('chtlc', 'active'); break;
    case 'CONTENT_PAID': setStep('chtlc', 'done', 'K received'); setStep('cmeta', 'active', 'Fetching...'); break;
    case 'CONTENT_PAYMENT_FAILED': setStep('cpay', 'fail', ev.data.reason || 'Failed'); showResult(false, 'Content payment failed'); break;

    // Chunked mode events — chunk metadata
    case 'CHUNK_META_RECEIVED': setStep('cmeta', 'done', ev.data.chunk_count ? ev.data.chunk_count + ' chunks' : ''); setStep('cbit', 'active'); break;
    case 'CHUNK_PLAN': setStep('cbit', 'done', ev.data.total_chunks ? ev.data.total_chunks + ' chunks planned' : ''); break;

    // Chunked mode events — transport payment + download
    case 'TRANSPORT_PAYING': setStep('tpay', 'active', 'Paying seeders...'); break;
    case 'TRANSPORT_PAYMENT_SENT': setStep('tpay', 'done', 'HTLC in flight'); setStep('thtlc', 'active'); break;
    case 'TRANSPORT_PAID': setStep('thtlc', 'done', 'Transport key received'); setStep('down', 'active'); break;
    case 'TRANSPORT_PAYMENT_FAILED': setStep('tpay', 'fail', 'Failed'); showResult(false, 'Transport payment failed'); break;
    case 'CHUNK_DOWNLOADED': setStep('down', 'active', ev.data.message || ''); break;
    case 'CHUNK_VERIFIED': setStep('down', 'active', 'Chunk ' + (ev.data.index ?? '') + ' verified'); break;
    case 'CHUNK_DOWNLOAD_FAILED': setStep('down', 'fail', ev.data.error || 'Failed'); break;

    // Chunked mode events — reassembly
    case 'CHUNKS_DOWNLOADING': setStep('down', 'active', ev.data.progress || ''); break;
    case 'CHUNKS_DOWNLOADED': setStep('down', 'done'); setStep('assem', 'active'); break;
    case 'ASSEMBLED': setStep('assem', 'done'); setStep('decrypt', 'active'); break;
  }
}

function tryPreview(data) {
  const container = document.getElementById('buyPreview');
  const file = data.output || data.path || '';
  if (!file || !nodeUrl) return;
  const url = nodeUrl + '/api/decrypted/' + file.split('/').pop();
  const ext = file.split('.').pop().toLowerCase();
  const fname = file.split('/').pop();
  container.style.display = 'block';
  if (['mp3', 'ogg', 'wav', 'opus', 'flac', 'aac', 'm4a'].includes(ext)) {
    container.innerHTML = `<audio controls src="${url}" style="width:100%;"></audio>`;
  } else if (['mp4', 'webm', 'mov'].includes(ext)) {
    container.innerHTML = `<video controls src="${url}" style="width:100%;"></video>`;
  } else if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg'].includes(ext)) {
    container.innerHTML = `<img src="${url}" alt="Preview">`;
  } else if (ext === 'pdf') {
    container.innerHTML = `<embed src="${url}" type="application/pdf" style="width:100%;height:500px;">
      <p><a href="${url}" target="_blank" class="btn btn-secondary">Open PDF: ${fname}</a></p>`;
  } else {
    container.innerHTML = `<div style="text-align:center;padding:1.5rem;">
      <div style="font-size:2rem;margin-bottom:0.5rem;">📄</div>
      <div style="color:#888;margin-bottom:0.8rem;">${ext.toUpperCase()} file &middot; ${fname}</div>
      <a href="${url}" target="_blank" class="btn btn-secondary" style="display:inline-block;padding:0.5rem 1.2rem;background:#222;color:#fff;border-radius:6px;text-decoration:none;">Download</a>
    </div>`;
  }
}

// ================================================================
// Collection: purchase history (localStorage)
// ================================================================
function recordPurchase(data) {
  if (!selectedItem) return;
  const purchase = {
    content_hash: selectedItem.content_hash || '',
    file_name: selectedItem.file_name || data.path?.split('/').pop() || 'unknown',
    price_sats: selectedItem.price_sats || 0,
    size_bytes: selectedItem.size_bytes || data.bytes || 0,
    output_path: data.path || data.output || '',
    purchased_at: new Date().toISOString(),
    mode: getMode(),
    creator_address: selectedItem.creator_address || '',
  };
  // Avoid duplicates (same content_hash)
  const existing = purchases.findIndex(p => p.content_hash === purchase.content_hash);
  if (existing >= 0) purchases[existing] = purchase;
  else purchases.unshift(purchase);
  localStorage.setItem('conduit_purchases', JSON.stringify(purchases));
  renderCollection();
  renderCatalog();
}

function renderCollection() {
  const container = document.getElementById('collectionList');
  const emptyMsg = document.getElementById('noCollection');
  if (!container) return;
  container.innerHTML = '';
  emptyMsg.style.display = purchases.length ? 'none' : 'block';
  purchases.forEach((p, idx) => {
    const div = document.createElement('div');
    div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:12px;border:1px solid #21262d;border-radius:8px;margin-bottom:8px;background:#161b22;';
    const ext = (p.file_name || '').split('.').pop().toUpperCase();
    const fileName = p.output_path ? p.output_path.split('/').pop() : '';
    const previewUrl = fileName && nodeUrl ? nodeUrl + '/api/decrypted/' + fileName : '';
    const date = p.purchased_at ? new Date(p.purchased_at).toLocaleDateString() : '';
    const modeLabel = p.mode === 'ad' ? 'Ad-subsidized' : p.mode === 'chunked' ? 'Chunked' : p.mode === 'seeder' ? 'Seeder' : 'Direct';
    div.innerHTML = `
      <div style="flex:1;">
        <div style="font-weight:600;color:#e6edf3;">${p.file_name || 'Unknown'}</div>
        <div style="font-size:11px;color:#8b949e;margin-top:2px;">
          ${ext} &middot; ${fmtSize(p.size_bytes || 0)} &middot; ${p.price_sats} sats &middot; ${modeLabel} &middot; ${date}
        </div>
        <div class="mono" style="font-size:10px;color:#484f58;margin-top:2px;">${(p.content_hash || '').slice(0, 32)}...</div>
      </div>
      <div style="display:flex;gap:6px;">
        ${previewUrl ? `<a href="${previewUrl}" target="_blank" class="btn btn-secondary" style="font-size:11px;padding:4px 10px;text-decoration:none;">Open</a>` : ''}
        <button class="btn btn-secondary" style="font-size:11px;padding:4px 10px;color:#f85149;" onclick="removePurchase(${idx})">Remove</button>
      </div>
    `;
    container.appendChild(div);
  });
}

function removePurchase(idx) {
  purchases.splice(idx, 1);
  localStorage.setItem('conduit_purchases', JSON.stringify(purchases));
  renderCollection();
}

// ================================================================
// Seeder: register + display
// ================================================================
async function registerSeed() {
  const filePath = document.getElementById('seedFilePath').value.trim();
  const encHash = document.getElementById('seedEncHash').value.trim();
  const price = parseInt(document.getElementById('seedPrice').value, 10);
  const statusEl = document.getElementById('seedStatus');

  if (!filePath) { statusEl.textContent = 'Encrypted file path is required'; statusEl.style.color = '#f85149'; return; }
  if (!encHash) { statusEl.textContent = 'Encrypted hash is required'; statusEl.style.color = '#f85149'; return; }
  if (!price || price < 1) { statusEl.textContent = 'Transport price must be at least 1 sat'; statusEl.style.color = '#f85149'; return; }
  if (!nodeUrl) { statusEl.textContent = 'Connect to a node first (Settings tab)'; statusEl.style.color = '#f85149'; return; }

  statusEl.textContent = 'Registering seed...';
  statusEl.style.color = '#8b949e';

  try {
    const r = await fetch(nodeUrl + '/api/seed', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        encrypted_file: filePath,
        encrypted_hash: encHash,
        transport_price: price,
      }),
    });
    const data = await r.json();
    if (data.error) {
      statusEl.textContent = 'Error: ' + data.error;
      statusEl.style.color = '#f85149';
    } else {
      statusEl.textContent = 'Seed registered successfully';
      statusEl.style.color = '#3fb950';
      setTimeout(() => loadSeederInfo(), 2000);
    }
  } catch (e) {
    statusEl.textContent = 'Failed: ' + e.message;
    statusEl.style.color = '#f85149';
  }
}

async function loadSeederInfo() {
  if (!nodeUrl) return;
  try {
    const r = await fetch(nodeUrl + '/api/catalog');
    const data = await r.json();
    // Seeder entries have transport_price > 0 or chunks_held
    const items = (data.items || data.catalog || (Array.isArray(data) ? data : [])).filter(i =>
      (i.transport_price && i.transport_price > 0) ||
      (i.chunks_held && i.chunks_held.length > 0)
    );
    const table = document.getElementById('seederTable');
    while (table.rows.length > 1) table.deleteRow(1);
    document.getElementById('noSeeds').style.display = items.length ? 'none' : 'block';
    items.forEach(item => {
      const row = table.insertRow();
      row.innerHTML = `
        <td>${item.file_name || '--'}</td>
        <td>${item.chunk_count || (item.chunks_held || []).length || '--'}</td>
        <td class="price">${item.transport_price || 0} sats</td>
        <td class="mono" title="${item.encrypted_hash || ''}">${(item.encrypted_hash || '').slice(0, 16)}...</td>
      `;
    });
  } catch (e) {}
}

// ================================================================
// Advertiser info
// ================================================================
async function loadAdvertiserInfo() {
  if (!nodeUrl) return;
  try {
    const r = await fetch(nodeUrl + '/api/advertiser/info');
    const info = await r.json();
    const status = document.getElementById('advStatus');
    if (info.enabled) {
      status.innerHTML = '<span class="badge badge-green">Enabled</span>';
      document.getElementById('advEnableHint').style.display = 'none';
      document.getElementById('advPubkey').textContent = info.advertiser_pubkey || '--';

      // Show stats if available
      if (info.total_paid_sats || info.payment_count) {
        document.getElementById('advStatsCard').style.display = 'block';
        document.getElementById('advTotalPaid').textContent = (info.total_paid_sats || 0).toLocaleString();
        document.getElementById('advPaymentCount').textContent = (info.payment_count || 0).toLocaleString();
      }

      // Load campaigns
      const cr = await fetch(nodeUrl + '/api/campaigns');
      const cdata = await cr.json();
      const campaigns = cdata.campaigns || [];
      const table = document.getElementById('advCampaignTable');
      while (table.rows.length > 1) table.deleteRow(1);
      document.getElementById('noCampaigns').style.display = campaigns.length ? 'none' : 'block';
      campaigns.forEach(c => {
        const pct = c.budget_total_sats > 0 ? Math.round(c.budget_spent_sats / c.budget_total_sats * 100) : 0;
        const row = table.insertRow();
        row.innerHTML = `
          <td>${c.name || '--'}</td>
          <td class="price">${c.subsidy_sats || 0} sats</td>
          <td>${(c.budget_spent_sats || 0).toLocaleString()} sats</td>
          <td>${(c.budget_total_sats || 0).toLocaleString()} sats (${pct}% used)</td>
          <td>${(c.duration_ms || 0) / 1000}s</td>
          <td><span class="badge ${c.active ? 'badge-green' : 'badge-red'}">${c.active ? 'Active' : 'Paused'}</span></td>
        `;
      });
    } else {
      status.innerHTML = '<span class="badge badge-yellow">Not enabled</span>';
      document.getElementById('advEnableHint').style.display = 'block';
    }
  } catch (e) {
    document.getElementById('advStatus').innerHTML = '<span class="badge badge-red">Error</span> <span style="font-size:12px;color:#8b949e;">' + e.message + '</span>';
  }
}

// ================================================================
// Network visualization (Scope 2: full network via fan-out)
// ================================================================
let netGraphBuilt = false;

async function loadNetworkGraph() {
  const status = document.getElementById('netStatus');
  const container = document.getElementById('networkGraph');
  if (!nodeUrl) { status.textContent = 'Connect to a node first (Settings tab).'; return; }

  status.textContent = 'Discovering network...';

  // -- 1. Collect data from this node + registry + all discovered nodes --
  const nodes = new Map();   // pubkey -> { id, label, role, address, channels:[] }
  const channels = [];       // { source, target, capacity, outbound, inbound, usable }
  const contentEdges = [];   // { creatorPk, seederPk, fileName }
  const seenChannels = new Set();

  function addNode(pk, role, address, alias) {
    if (!pk) return;
    const existing = nodes.get(pk);
    if (existing) {
      if (role !== 'peer' && existing.role === 'peer') existing.role = role;
      if (address && !existing.address) existing.address = address;
      if (alias && !existing.alias) { existing.alias = alias; existing.label = alias; }
    } else {
      const displayLabel = alias || (pk.slice(0, 8) + '...');
      nodes.set(pk, { id: pk, label: displayLabel, alias: alias || '', role: role || 'peer', address: address || '' });
    }
  }

  function addChannels(ownerPk, chList) {
    (chList || []).forEach(ch => {
      const cpk = ch.counterparty_node_id;
      if (!cpk) return;
      const key = [ownerPk, cpk].sort().join(':') + ':' + (ch.channel_id || ch.value_sats);
      if (seenChannels.has(key)) return;
      seenChannels.add(key);
      addNode(cpk, 'peer', '');
      channels.push({
        source: ownerPk, target: cpk,
        capacity: ch.value_sats || ch.channel_value_sats || 0,
        outbound: Math.round((ch.outbound_msat || ch.outbound_capacity_msat || 0) / 1000),
        inbound: Math.round((ch.inbound_msat || ch.inbound_capacity_msat || 0) / 1000),
        usable: ch.usable || ch.is_usable || false,
        ready: ch.ready || ch.is_channel_ready || false,
      });
    });
  }

  // Fetch with timeout helper
  async function fetchJson(url, timeoutMs) {
    const ctrl = new AbortController();
    const timer = setTimeout(() => ctrl.abort(), timeoutMs || 5000);
    try {
      const r = await fetch(url, { signal: ctrl.signal });
      clearTimeout(timer);
      return await r.json();
    } catch (e) {
      clearTimeout(timer);
      return null;
    }
  }

  // -- 1a. This node's info --
  let selfPk = null;
  try {
    const info = await fetchJson(nodeUrl + '/api/info', 5000);
    if (info && info.node_id) {
      selfPk = info.node_id;
      addNode(selfPk, 'self', nodeUrl, info.node_alias || '');
      addChannels(selfPk, info.channels);
    }
  } catch (e) {}

  // -- 1b. Registry data --
  let listings = [], seeders = [];
  if (registryUrl) {
    const [lr, sr] = await Promise.all([
      fetchJson(registryUrl + '/api/listings', 5000),
      fetchJson(registryUrl + '/api/seeders?all=1', 5000),
    ]);
    listings = (lr && lr.items) || [];
    seeders = (sr && sr.items) || [];
  }

  // Index creators and seeders
  const creatorAddrs = new Map();
  listings.forEach(l => {
    const pk = l.creator_pubkey;
    const addr = ensureHttp(l.creator_address || l.creator_ln_address);
    if (pk) { addNode(pk, 'creator', addr, l.creator_alias || ''); creatorAddrs.set(pk, addr); }
  });

  const seederAddrs = new Map();
  seeders.forEach(s => {
    const pk = s.seeder_pubkey;
    const addr = ensureHttp(s.seeder_address || s.seeder_ln_address);
    if (pk) { addNode(pk, 'seeder', addr, s.seeder_alias || ''); seederAddrs.set(pk, addr); }
  });

  // Build content edges: which seeders carry which creators' content
  const contentMap = new Map();
  listings.forEach(l => { if (l.encrypted_hash && l.creator_pubkey) contentMap.set(l.encrypted_hash, l); });
  seeders.forEach(s => {
    const listing = contentMap.get(s.encrypted_hash);
    if (listing && listing.creator_pubkey && s.seeder_pubkey && listing.creator_pubkey !== s.seeder_pubkey) {
      const key = listing.creator_pubkey + ':' + s.seeder_pubkey;
      if (!contentEdges.find(e => e.key === key)) {
        contentEdges.push({ key, creatorPk: listing.creator_pubkey, seederPk: s.seeder_pubkey, fileName: listing.file_name || '' });
      }
    }
  });

  // -- 1c. Fan out to all discovered node addresses --
  status.textContent = 'Querying discovered nodes...';
  const addressesToQuery = new Set();
  creatorAddrs.forEach((addr) => { if (addr && addr !== nodeUrl) addressesToQuery.add(addr); });
  seederAddrs.forEach((addr) => { if (addr && addr !== nodeUrl) addressesToQuery.add(addr); });
  // Also check channel peers that might have known addresses
  nodes.forEach(n => { if (n.address && n.address !== nodeUrl) addressesToQuery.add(n.address); });

  const fanOutResults = await Promise.allSettled(
    [...addressesToQuery].map(addr => fetchJson(addr + '/api/info', 4000))
  );
  fanOutResults.forEach(r => {
    if (r.status === 'fulfilled' && r.value && r.value.node_id) {
      const info = r.value;
      if (info.node_alias) {
        const existingNode = nodes.get(info.node_id);
        if (existingNode && !existingNode.alias) {
          existingNode.alias = info.node_alias;
          existingNode.label = info.node_alias;
        }
      }
      addChannels(info.node_id, info.channels);
    }
  });

  // Detect advertiser: node with /api/campaigns endpoint
  const advChecks = await Promise.allSettled(
    [...addressesToQuery].map(async addr => {
      const r = await fetchJson(addr + '/api/campaigns', 3000);
      if (r && (r.campaigns !== undefined)) {
        // Find which node this address belongs to
        for (const [pk, n] of nodes) {
          if (n.address === addr && n.role !== 'self') { n.role = 'advertiser'; break; }
        }
      }
    })
  );

  // -- 2. Build D3 graph --
  const nodeArr = [...nodes.values()];
  const linkArr = [];

  // Channel edges
  channels.forEach(ch => {
    if (nodes.has(ch.source) && nodes.has(ch.target)) {
      linkArr.push({
        source: ch.source, target: ch.target,
        type: 'channel', capacity: ch.capacity,
        outbound: ch.outbound, inbound: ch.inbound,
        usable: ch.usable, ready: ch.ready,
      });
    }
  });

  // Content edges
  contentEdges.forEach(ce => {
    if (nodes.has(ce.creatorPk) && nodes.has(ce.seederPk)) {
      linkArr.push({
        source: ce.creatorPk, target: ce.seederPk,
        type: 'content', fileName: ce.fileName,
      });
    }
  });

  status.textContent = nodeArr.length + ' nodes, ' + channels.length + ' channels, ' + contentEdges.length + ' content links';

  renderNetworkGraph(container, nodeArr, linkArr, selfPk);
}

function renderNetworkGraph(container, nodeArr, linkArr, selfPk) {
  // Clear previous SVG
  d3.select(container).select('svg').remove();

  const width = container.clientWidth;
  const height = container.clientHeight || 520;

  const svg = d3.select(container).append('svg')
    .attr('width', width).attr('height', height)
    .attr('viewBox', [0, 0, width, height]);

  // Zoom
  const g = svg.append('g');
  svg.call(d3.zoom().scaleExtent([0.3, 5]).on('zoom', (e) => g.attr('transform', e.transform)));

  // Role colors
  const roleColor = { self: '#f0883e', creator: '#58a6ff', seeder: '#3fb950', advertiser: '#bc8cff', peer: '#8b949e' };
  const roleRadius = { self: 18, creator: 14, seeder: 12, advertiser: 13, peer: 10 };

  // Arrow marker for content edges
  svg.append('defs').append('marker')
    .attr('id', 'arrowContent').attr('viewBox', '0 -4 8 8').attr('refX', 24).attr('refY', 0)
    .attr('markerWidth', 6).attr('markerHeight', 6).attr('orient', 'auto')
    .append('path').attr('d', 'M0,-4L8,0L0,4').attr('fill', '#30363d');

  // Force simulation
  const sim = d3.forceSimulation(nodeArr)
    .force('link', d3.forceLink(linkArr).id(d => d.id).distance(d => d.type === 'channel' ? 140 : 200))
    .force('charge', d3.forceManyBody().strength(-400))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide().radius(d => (roleRadius[d.role] || 10) + 8));

  // Links
  const link = g.append('g').selectAll('line').data(linkArr).join('line')
    .attr('stroke', d => d.type === 'channel' ? (d.usable ? '#58a6ff' : '#484f58') : '#30363d')
    .attr('stroke-width', d => {
      if (d.type === 'content') return 1;
      return Math.max(1.5, Math.min(5, (d.capacity || 0) / 50000));
    })
    .attr('stroke-dasharray', d => d.type === 'content' ? '4,4' : null)
    .attr('marker-end', d => d.type === 'content' ? 'url(#arrowContent)' : null)
    .attr('pointer-events', 'stroke');

  // Node groups
  const node = g.append('g').selectAll('g').data(nodeArr).join('g')
    .call(d3.drag()
      .on('start', (e, d) => { if (!e.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
      .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
      .on('end', (e, d) => { if (!e.active) sim.alphaTarget(0); d.fx = null; d.fy = null; })
    );

  // Node circles
  node.append('circle')
    .attr('r', d => roleRadius[d.role] || 10)
    .attr('fill', d => roleColor[d.role] || '#8b949e')
    .attr('stroke', d => d.role === 'self' ? '#f0883e' : '#21262d')
    .attr('stroke-width', d => d.role === 'self' ? 3 : 1.5);

  // Node labels (alias or role name)
  node.append('text')
    .text(d => {
      if (d.alias) return d.alias;
      if (d.role === 'self') return 'You';
      return d.role.charAt(0).toUpperCase() + d.role.slice(1);
    })
    .attr('dy', d => (roleRadius[d.role] || 10) + 14)
    .attr('text-anchor', 'middle')
    .attr('fill', d => d.alias ? '#e6edf3' : '#8b949e')
    .attr('font-size', '11px')
    .attr('font-weight', d => (d.role === 'self' || d.alias) ? '600' : '400');

  // Pubkey below name
  node.append('text')
    .text(d => d.id.slice(0, 8) + '...')
    .attr('dy', d => (roleRadius[d.role] || 10) + 26)
    .attr('text-anchor', 'middle')
    .attr('fill', '#484f58')
    .attr('font-size', '9px')
    .attr('font-family', "'SF Mono', monospace");

  // Tooltip
  const tooltip = d3.select('#netTooltip');

  node.on('mouseenter', (e, d) => {
    let html = '';
    if (d.alias) html += '<span class="tt-label">Alias:</span> <span class="tt-value" style="font-weight:700;">' + d.alias + '</span><br>';
    html += '<span class="tt-label">Node ID:</span> <span class="tt-value">' + d.id.slice(0, 24) + '...</span><br>';
    html += '<span class="tt-label">Role:</span> <span class="tt-value">' + d.role + '</span><br>';
    if (d.address) html += '<span class="tt-label">Address:</span> <span class="tt-value">' + d.address + '</span><br>';
    // Find channels for this node
    const nodeChannels = linkArr.filter(l => l.type === 'channel' && (l.source.id === d.id || l.target.id === d.id));
    if (nodeChannels.length) {
      html += '<span class="tt-label">Channels:</span> <span class="tt-value">' + nodeChannels.length + '</span><br>';
      let totalCap = 0;
      nodeChannels.forEach(c => totalCap += (c.capacity || 0));
      html += '<span class="tt-label">Total capacity:</span> <span class="tt-value">' + totalCap.toLocaleString() + ' sats</span>';
    }
    tooltip.html(html).style('display', 'block');
    const rect = container.getBoundingClientRect();
    tooltip.style('left', (e.clientX - rect.left + 14) + 'px').style('top', (e.clientY - rect.top - 10) + 'px');
  })
  .on('mousemove', (e) => {
    const rect = container.getBoundingClientRect();
    tooltip.style('left', (e.clientX - rect.left + 14) + 'px').style('top', (e.clientY - rect.top - 10) + 'px');
  })
  .on('mouseleave', () => tooltip.style('display', 'none'));

  // Channel edge tooltips
  link.on('mouseenter', (e, d) => {
    let html = '';
    if (d.type === 'channel') {
      html += '<span class="tt-label">Channel</span><br>';
      html += '<span class="tt-label">Capacity:</span> <span class="tt-value">' + (d.capacity || 0).toLocaleString() + ' sats</span><br>';
      html += '<span class="tt-label">Outbound:</span> <span class="tt-value">' + (d.outbound || 0).toLocaleString() + ' sats</span><br>';
      html += '<span class="tt-label">Inbound:</span> <span class="tt-value">' + (d.inbound || 0).toLocaleString() + ' sats</span><br>';
      html += '<span class="tt-label">Status:</span> <span class="tt-value">' + (d.usable ? 'Usable' : d.ready ? 'Ready' : 'Pending') + '</span>';
    } else {
      html += '<span class="tt-label">Content link</span><br>';
      if (d.fileName) html += '<span class="tt-label">File:</span> <span class="tt-value">' + d.fileName + '</span>';
    }
    tooltip.html(html).style('display', 'block');
    const rect = container.getBoundingClientRect();
    tooltip.style('left', (e.clientX - rect.left + 14) + 'px').style('top', (e.clientY - rect.top - 10) + 'px');
  })
  .on('mousemove', (e) => {
    const rect = container.getBoundingClientRect();
    tooltip.style('left', (e.clientX - rect.left + 14) + 'px').style('top', (e.clientY - rect.top - 10) + 'px');
  })
  .on('mouseleave', () => tooltip.style('display', 'none'));

  // Simulation tick
  sim.on('tick', () => {
    link
      .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
    node.attr('transform', d => `translate(${d.x},${d.y})`);
  });
}

// Hook into tab switching: load network when tab is activated
const origTabHandler = document.querySelectorAll('.tab-bar button');
origTabHandler.forEach(btn => {
  btn.addEventListener('click', () => {
    if (btn.dataset.tab === 'network' && nodeUrl) loadNetworkGraph();
  });
});

// ================================================================
// Utility
// ================================================================
function fmtSize(b) {
  if (b < 1024) return b + ' B';
  if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
  return (b / 1048576).toFixed(1) + ' MB';
}

// ================================================================
// Auto-connect on load
// ================================================================
renderCollection();  // Show purchases from localStorage immediately
if (nodeUrl) {
  connectNode();
}
</script>
</body>
</html>
